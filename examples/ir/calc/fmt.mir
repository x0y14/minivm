.export _print
.export _println
.export _print_int
.export _println_int

.section .data:
    newline auto '\n', '\0'
    newlineLen sizeof newline

.section .text:

; r1=heapBaseAddr -> r2=len (until '\0')
__strlen:
    mov r2 0
__strlen_loop:
    load r3 r1
    eq r3 0
    jz __strlen_done
    add r1 1
    add r2 1
    jmp __strlen_loop
__strlen_done:
    ret

__print_newline:
    mov r0 1      ; SYS_WRITE
    mov r1 1      ; stdout
    mov r2 newline
    mov r3 newlineLen
    syscall
    ret

; print(heapAddr, length)
_print:
    mov r3 r2     ; length
    mov r2 r1     ; heapAddr
    mov r0 1      ; SYS_WRITE
    mov r1 1      ; stdout
    syscall
    ret

; println(heapAddr, length)
_println:
    call _print
    call __print_newline
    ret

; print_int(n)  ; r1=n (>=0)
; 1) 桁数だけ先に数える -> len
; 2) len+1 を確保し（終端 '\0' 分）、末尾から文字を書き込む
; 3) 末尾に '\0' を置き、__strlen で長さを測って _print
_print_int:
    push r1               ; preserve n

    mov r5 r1
    eq r5 0
    jz _print_zero        ; n == 0 の特別扱い

    ; --- pass1: 桁数カウント ---
    mov r6 0              ; r6 = 桁数
_print_int_count_loop:
    mov r8 0              ; q
    mov r9 r5             ; r = n
_print_int_div1:
    lt r9 10
    jz _print_int_div1_done
    sub r9 10
    add r8 1
    jmp _print_int_div1
_print_int_div1_done:
    add r6 1              ; 1 桁確定
    mov r5 r8             ; n = q
    eq r5 0
    jnz _print_int_count_loop

    ; len+1 を確保（終端用に +1）
    mov r3 r6
    add r3 1
    alloc r3
    pop r4                ; r4 = heap base
    pop r10               ; r10 = original n（呼び出し元保存用）
    ; 書き込み開始位置（末尾から）
    mov r7 r4
    add r7 r6
    sub r7 1

    ; --- pass2: 文字列生成（末尾から書く） ---
    mov r5 r10            ; n = original n
_print_int_write_loop:
    mov r8 0              ; q
    mov r9 r5             ; r = n
_print_int_div2:
    lt r9 10
    jz _print_int_div2_done
    sub r9 10
    add r8 1
    jmp _print_int_div2
_print_int_div2_done:
    add r9 48             ; '0'
    store r7 r9
    sub r7 1
    mov r5 r8             ; n = q
    eq r5 0
    jnz _print_int_write_loop

    ; 末尾に '\0'
    mov r3 0
    mov r2 r4
    add r2 r6
    store r2 r3

    ; 長さ測定 -> _print
    mov r1 r4
    call __strlen         ; r1 は走査で進むので注意
    mov r1 r4             ; base を戻す
    call _print           ; r1=base, r2=len

    mov r1 r10            ; 呼び出し元 r1 を復元
    ret

_print_zero:
    ; "0\0" を作って __strlen -> _print
    alloc 2
    pop r4
    mov r5 48             ; '0'
    store r4 r5
    mov r5 0              ; '\0'
    mov r2 r4
    add r2 1
    store r2 r5
    mov r1 r4
    call __strlen         ; r2=1
    mov r1 r4
    call _print
    pop r1
    ret

; println_int(n)
_println_int:
    call _print_int
    call __print_newline
    ret
